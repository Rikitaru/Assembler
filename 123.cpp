#include <iostream>

int main() {
	short mas[10];
	int index;
	int tmp;

	char type_data_in[] = "%hd";
	char type_data_out[] = "%hd ";

	__asm {
		/*В функциях scanf и printf управляющая строка самая левая, а аргументы справа, 
		то в стек кладем все параметры справа налево, так как правило стека LIFO */

		//Ввод массива
		mov ecx, 10				//В есх 10, так как 10 итераций цикла
		lea ebx, mas			//Кладем в ebx адрес начала массива
	enter_mas:					
		mov tmp, ecx			//Так как вызов функций scanf и printf не гарантирует сохранность регистров - сохраняем в i значение ecx
		//Ввод очередного элемента массива
		push ebx				//Кладем в стек адрес элемента
		lea esi, type_data_in	//Кладем в esi адрес управляющей строки
		push esi				//Кладем в стек адрес управляющей строки
		call scanf				//Вызываем функцию scanf
		add esp, 8				//Перемещаем стековый указатель на 4*n байт, то есть в исходное состояние (n - кол-во элементов, которое положили в стек)
		inc ebx					//Инкрементируем ebx два раза, так как short 2 байта
		inc ebx
		mov ecx, tmp			//Кладем в ecx значение, которое запомнили в самом начале для цикла loop
		loop enter_mas


		//Поиск максимального элемента
		mov bx, mas[0]		//В bx максимальный элемент
		mov index, 10		//Индекс максимального элемента (ВАЖНО! Индексы я считал от 10 до 1, чтобы не париться с вычитанием и т.д.)
		mov ecx, 9			//В есх 9, так как мы с саммого начала сделали первый элемент максимальным, а значит начинаем со второго
		mov esi, 2			//Индексный регистр равен 2 с самого начала, так как начинаем со второго элемента
	search:
		mov ax, mas[esi]	//В ax очередной элемент массива
		cmp ax, bx			//Сравниваем с максимальным
		jng no_max			//Если ax меньше или равно максимальному элементу, то прыгаем
		mov bx, ax			//Если ax больше, то кладем в bx ах
		mov index, ecx		//Меняем индекс максимального элемента
	no_max:
		inc esi				//Инкремент два раза, так как short 2 байта
		inc esi
		loop search

	
		//Обработка массива
		mov ecx, 10
		xor esi, esi
	data_processing:
		cmp ecx, index		//Сравниваю текущий индекс (есх) и индекс максимального элемента
		jng skip_zeroing	//Если текущий индекс равен или меньше индекса макс. элемента, то прыгаем
		mov mas[esi], 0		//Обнуление элемента
		jmp skip
	skip_zeroing:
		mov mas[esi], bx	//Запись в текущий элемент массива макс. значение
	skip:
		inc esi
		inc esi
		loop data_processing

		//Аналогично вводу
		//Вывод массива
		mov ecx, 10
		lea ebx, mas
	print_mas:
		//Кладем значение из массива
		mov tmp, ecx
		push[ebx]				//Здесь в стек необходимо уже положить значение по адресу, поэтому []
		//Кладем строчку
		lea esi, type_data_out
		push esi
		call printf
		add esp, 8
		inc ebx
		inc ebx
		mov ecx, tmp
		loop print_mas
	}
	return 0;
}